(* ::Package:: *)

(* ::Input:: *)
(*BeginPackage["MyLambdaInterpreter`"];*)
(**)
(*(*Exported symbols*)*)
(*LambdaInterpret::usage="Interpret a lambda expression, passed as a string. ";*)
(*LambdaStepNum::usage="is the maximum number of steps for the interpreter.";*)
(*LambdaREPL::usage = "open a REPL for lambda expressions. can pass input and output files as arguments";*)
(*Begin["`Private`"];*)


(* ::Input:: *)
(**)
(*(* ---- Tokenizer ---- *)*)
(*Clear[tokenize]*)
(*tokenize[inputString_] := *)
(*	StringCases[inputString,*)
(*	{*)
(*	s: RegularExpression["\[Lambda]|\\\\|@" ] :> {lambda, \[Lambda]},*)
(*	s: "." :> {dot, "."},*)
(*	s: "(" :>  {openBrac, "("},*)
(*	s: ")" :> {closeBrac, "+"},*)
(*	s: "let" :> {let, "let"},*)
(*	s: "=" :> {equal, "="},*)
(*	s: "in" :> {in, "in"},*)
(**)
(*s: RegularExpression["[0-9]+"] :> {num, s},*)
(*	s: RegularExpression["[A-Z][A-Za-z0-9_]*"] :> {macro, s},*)
(*	s: RegularExpression["[a-z][A-Za-z0-9_]*"] :> {varName, s}*)
(*	}];*)
(**)
(**)


(* ::Input:: *)
(*(*---- Parser ----*)*)


(* ::Input:: *)
(*(*Abstract Syntax Tree (AST) Definitions*)*)
(*ClearAll[lamVar,lamAbs,lamApp,lamNum,lamLet,lamFunc, foldRight]*)
(*foldRight[ f_, x_, list_ ] := f[First[list], foldRight[f, x, Drop[list, 1]]];*)
(*foldRight[ f_, x_, {} ] := x;*)
(**)


(* ::Input:: *)
(*(*Recursive Descent Parser*)*)
(*parse[tokens_List]:=*)
(*Module[{currentToken,tokenIndex=1,len=Length[tokens]},(*Helper function to advance to the next token*)*)
(*advanceToken[]:=( *)
(*If[tokenIndex<=len,*)
(*currentToken=tokens[[tokenIndex]];*)
(*tokenIndex++;*)
(*,*)
(*currentToken={EOF,"$"} (*End of File token*)*)
(*];*)
(*);*)
(*(*Helper function to check and consume an expected token type*)*)
(*expect[expectedType_]:=(If[currentToken[[1]]===expectedType,*)
(*Module[{value=currentToken[[2]]},(*Store the value before advancing*)*)
(*advanceToken[];*)
(*value*)
(*]*)
(*,*)
(*Throw["Parsing error: Expected "<>ToString[expectedType]<>", found "<>ToString[currentToken[[1]]]] <>  "(" <> currentToken[[2]]<>")"]*)
(*);*)
(*(*Helper function to peek at the current token type without consuming*)*)
(*peek[]:=currentToken[[1]];*)
(*(*Grammar Rules*)(* <expression> ::='let'<var>'='<expression>'in'<expression> | <abstraction> | <application>*)*)
(*parseExpression[]:=If[peek[]===let,expect[let];*)
(*Module[{var,val,bod},var=expect[varName];*)
(*expect[equal];*)
(*val=parseExpression[];*)
(*expect[in];*)
(*bod=parseExpression[];*)
(*lamLet[var,val,bod]],parseApplication[] (*Application has higher precedence than abstraction*)];*)
(*(* <abstraction> ::='\[Lambda]'<varlist>'.'<expression>*)*)
(*parseAbstraction[]:=(expect[lambda];(*Consume the lambda token*)*)
(*Module[{vars={},bod,r},*)
(*While[peek[]===varName,*)
(*AppendTo[vars,expect[varName]]*)
(*];*)
(*expect[dot];*)
(*bod=parseExpression[];*)
(*(*Create nested lambda abstractions using Fold with reversed variables*)foldRight[lamAbs,bod,vars]]);*)
(*(* <application> ::= <atom>{ <atom>}*)*)
(*parseApplication[]:=*)
(*Module[{func=parseAtom[],arg},*)
(*While[MemberQ[{varName,openBrac,num,macro,lambda},peek[]],(*Atom can start with these*)*)
(*arg=parseAtom[];*)
(*func=lamApp[func,arg]];*)
(*func*)
(*];*)
(*(* <varlist> ::= <var>{ <var>}-Handled directly in parseAbstraction*)(* <atom> = <var> |'(', <expr> ,')'| <number> | <macro>;*)*)
(*parseAtom[]:=*)
(*Switch[peek[],*)
(*varName,lamVar[expect[varName]],*)
(*num,lamNum[ToExpression[expect[num]]],*)
(*macro,lamMacro[expect[macro]],*)
(*lambda,parseAbstraction[],*)
(*openBrac,expect[openBrac]; Module[{expr=parseExpression[]},expect[closeBrac];expr],*)
(*_,Throw["Syntax error: Unexpected token "<>ToString[currentToken[[1]]]<>" at atom parsing"]*)
(*];*)
(**)
(*(*Start parsing*)*)
(*advanceToken[];*)
(*(*Initialize currentToken*)*)
(*parseExpression[]];*)
(**)
(*(*Define a custom message for syntax errors*)*)


(* ::Input:: *)
(*(*---- Macro definitions ----*)*)


(* ::Input:: *)
(*defaultMacroDict = <|*)
(*"SUCC"->parse[tokenize["@n.@f.@x. f (n f x)"]],*)
(*"PLUS"->parse[tokenize["@n.@m. n SUCC m"]],*)
(*"MULT"->parse[tokenize["@m.@n.@f. m (n f)"]],*)
(*"POW"->parse[tokenize["@m.@n. n m"]],*)
(*"TRUE"-> parse[tokenize["@x.@y. x"]],*)
(*"FALSE"-> parse[tokenize["@x.@y. y"]],*)
(*"IF"->parse[tokenize["@p.@x.@y. p x y"]],*)
(*"ISZERO"->parse @ tokenize["@n. n (@x. FALSE) TRUE"],*)
(*"NOT"->parse@tokenize["@p.@x.@y. p y x"],*)
(*"AND"->parse@tokenize["@p1.@p2. p1 p2 p1"],*)
(*"OR"->parse@tokenize["@p1.@p2. p1 p1 p2"],*)
(*"XOR"->parse@tokenize["@p1.@p2. p1 (NOT p2) p2"],*)
(*"Y"->parse@tokenize["@f. (@x. f (x x)) (@x. f (x x))"],*)
(*"PRED"->parse@tokenize["\[Lambda]n.\[Lambda]f.\[Lambda]x.n (\[Lambda]g.\[Lambda]h.h (g f)) (\[Lambda]u.x) (\[Lambda]u.u)"],*)
(*"MINUS"->parse@tokenize["@m.@n. n PRED m"],*)
(*"LEQ"->parse@tokenize["@n.@m. ISZERO (MINUS n m)"],*)
(*"I"-> parse@tokenize["@x. x"], *)
(*"K" -> parse@tokenize["@x.@f. x"],*)
(*"S"->  parse@tokenize["@x.@y.@z. ((x z) (y z))"],*)
(*"Z" -> parse@tokenize["@f.(@x. f(@v.x x v)) (@x. f(@v.x x v))"]*)
(*|>;*)
(**)
(*macroDict = defaultMacroDict;*)


(* ::Input:: *)
(*(* ---- Reducer ----*)*)


(* ::Input:: *)
(*freeVars[lamVar[x_]] := {x}*)
(*freeVars[lamAbs[x_, bod_]]:= Complement[freeVars[bod], {x}]*)
(*freeVars[lamApp[f_, a_]] := Union[freeVars[f], freeVars[a]]*)
(*freeVars[lamLet[var_, val_, bod_]] := Union[Complement[freeVars[bod], {x}], freeVars[val]]*)
(*freeVars[t_] := {}*)
(**)
(*alphaSub[x_, bod_]  := Module[{freshVar = Symbol["v" <> ToString[Unique[]]]}, *)
(*		{freshVar, substitute[bod, x, lamVar[freshVar]]}]*)


(* ::Input:: *)
(*uniqueCounter = 0;*)
(*uniqueIndex[] := uniqueCounter = uniqueCounter+1*)


(* ::Input:: *)
(*(*substitute:Substitutes'newVal' for'x' in'term'.*)*)
(*(*This is a core function for beta-reduction and let-expansion.*)*)
(*substitute[lamVar[x_],x_,newVal_]:=newVal*)
(*substitute[lamVar[x_],y_,newVal_]:=lamVar[x]*)
(**)
(*(*Substitution in abstraction (lamAbs):*)*)
(*substitute[lamAbs[boundVar_,bod_],boundVar_,newVal_]:= lamAbs[boundVar,bod]*)
(*substitute[lamAbs[boundVar_,bod_],x_,newVal_] :=*)
(*If[MemberQ[freeVars[newVal], boundVar],*)
(*(*Capture detected! alpha-rename this lambda.*)*)
(*Module[{freshVar=Symbol["v"<>ToString[uniqueIndex[]]]},*)
(*lamAbs[freshVar,substitute[substitute[bod,boundVar,lamVar[freshVar]],x,newVal]]]*)
(*,*)
(*lamAbs[boundVar,substitute[bod,x,newVal]]*)
(*]*)
(**)
(*(*Substitution in application (lamApp):*)*)
(*substitute[lamApp[f_,b_],toSub_,newVal_]:=lamApp[substitute[f,toSub,newVal],substitute[b,toSub,newVal]]*)
(**)
(*(*Substitution in let-binding (lamLet):*)*)
(*substitute[lamLet[boundVar_,val_,bod_],boundVar_,newVal_] := lamLet[boundVar,substitute[val, toSub, newVal],bod]*)
(*substitute[lamLet[boundVar_,val_,bod_],toSub_,newVal_]:=*)
(*If[MemberQ[freeVars[newVal], boundVar],(*Capture detected! alpha-rename this let.*)*)
(*Module[{freshVar=Symbol["v"<>ToString[uniqueIndex[]]]},*)
(*lamLet[freshVar,substitute[val,toSub,newVal],*)
(*substitute[substitute[bod,boundVar,lamVar[freshVar]],toSub,newVal]*)
(*]*)
(*]*)
(*,*)
(*(*No capture,proceed with substitution in both val and bod.*)*)
(*lamLet[boundVar,substitute[val,toSub,newVal],substitute[bod,toSub,newVal]]*)
(*]*)
(**)
(*(*Catch-all for other types (lamNum,lamMacro) that don't have variables to substitute into directly*)*)
(*substitute[A_,_,_]:=A (*Catch-all for other types like lamNum,which don't have variables to substitute into directly*)*)
(**)


(* ::Input:: *)
(*(*churchNum:Converts an integer'n' into its Church numeral representation.*)*)
(*churchNum[n_] := Module[{chruchNumAux},*)
(*churchNumAux[0] := lamVar["x"];*)
(*churchNumAux[m_] :=lamApp[lamVar["f"], churchNumAux[m-1]];*)
(*lamAbs["f", lamAbs["x", churchNumAux[n]]]*)
(*]*)


(* ::Input:: *)
(*(*reduceOnce:Performs a single step of beta-reduction or other simplification.*)*)
(*Clear[reduceOnce]*)
(*(*Beta-reduction:(\[Lambda]x.bod) arg->bod[x/arg]*)*)
(*reduceOnce[lamApp[lamAbs[x_, bod_], arg_]] :=substitute[bod, x, arg]*)
(**)
(*(*Apply reduction recursively to the abstraction*)*)
(*reduceOnce[lamApp[f_, a_]] /;reduceOnce[f] =!= f:= lamApp[reduceOnce[f], a]*)
(*reduceOnce[lamApp[f_, a_]] := lamApp[f, reduceOnce[a]]*)
(*reduceOnce[lamAbs[x_, bod_]] := lamAbs[x, reduceOnce[bod]]*)
(**)
(*(*Eta reduction:\[Lambda]x.(f x)->f (if x is not free in f)*)*)
(*reduceOnce[lamAbs[x_, lamApp[f_, lamVar[x_]]]] := *)
(*If[!MemberQ[freeVars[f],x],*)
(*f,*)
(*lamAbs[x,lamApp[f,lamVar[x]]]*)
(*]*)
(**)
(*(*Convert a lamNum node to its Church numeral representation*)*)
(*reduceOnce[lamNum[n_]] := churchNum[n]*)
(**)
(*(*Let-expansion:let var=val in bod->bod[var/val]*)*)
(*reduceOnce[lamLet[var_, val_,  bod_]] := substitute[bod, var, val]*)
(**)
(*(*Macro expansion:If a lamMacro node is encountered,expand it using the macroDictionary.*)*)
(*reduceOnce[lamMacro[name_]]:=*)
(*If[KeyExistsQ[macroDict,name],*)
(*	macroDict[name],(*Return the stored AST for the macro*)*)
(*	lamMacro[name] (*If for some reason it's not found (e.g.,deleted),return itself*)*)
(*]*)
(**)
(*(*Catch-all:If no reduction rule applies,return the term unchanged*)*)
(*reduceOnce[term_] := term*)
(**)


(* ::Input:: *)
(*reduce[term_, 0] := {term}*)
(*reduce[term_, steps_] := *)
(*Module[{r1 =reduceOnce[term]}, *)
(*If[r1 === term,*)
(*	{term},*)
(*	Prepend[reduce[r1, steps -1], term]]*)
(*]*)


(* ::Input:: *)
(*(*---- Output formater ----*)*)


(* ::Input:: *)
(*Clear[pretty]*)
(*(*Precedence levels for pretty printing*)(*Lower number means lower precedence (binds less tightly)*)(*Higher number means higher precedence (binds more tightly)*)*)
(*$AppPrec=100;    (*Applications have high precedence (e.g.,f x y)*)*)
(*$AbsPrec=5;     (*Abstractions bind loosely,extend to the right (e.g., \x.M N)*)*)
(*$LetPrec=5;     (*Let expressions bind loosely,similar to abstractions*)*)
(*$AtomPrec=1000;  (*Atoms (vars,nums,macros) always print as-is,highest precedence*)*)
(**)
(**)
(*(*Main pretty function with an optional'parentPrecedence' argument. This argument helps decide if the current expression needs outer parentheses.*)*)
(*pretty[lamVar[x_], ___]:= ToString[x]*)
(*pretty[lamMacro[f_], ___] := ToString[f]*)
(*pretty[lamNum[n_], ___] := ToString[n]*)
(*pretty[expr_,parentPrecedence_:0]:=*)
(*Module[{resultString,currentPrecedence},*)
(*Switch[Head[expr],*)
(*lamAbs,*)
(*Module[{vars,actualBod,bodStr},*)
(*(*Collect consecutive lambda variables: \x y z.M*)*)
(*{vars,actualBod}=collectLambdaChain[expr];*)
(*(*Recursively pretty-print the body with the abstraction's precedence*)*)
(*bodStr=pretty[actualBod,$AbsPrec];*)
(*resultString="\[Lambda]"<>StringJoin[Riffle[ToString/@vars," "]]<>"."<>bodStr;*)
(*currentPrecedence=$AbsPrec;];*)
(*,*)
(*lamApp,*)
(*Module[{f=expr[[1]],a=expr[[2]],prettyF,prettyA},*)
(*(*Function part of application:print with own precedence*)*)
(*prettyF=pretty[f,$AppPrec];*)
(*(*Argument part of application:higher precedence to ensure its parens*)*)
(*(*This handles cases like f (g h) where g h needs parens, but not (f g) h which becomes f g h*)*)
(*prettyA=pretty[a,$AppPrec+1];*)
(*resultString=prettyF<>" "<>prettyA;*)
(*currentPrecedence=$AppPrec;*)
(*];*)
(*,*)
(*lamLet,*)
(*Module[{var=expr[[1]],val=expr[[2]],bod=expr[[3]]},*)
(*(*Value part of let:higher precedence to ensure its parens if complex*)*)
(*resultString="let "<>ToString[var]<>" = "<>pretty[val,$LetPrec+1]<>" in "<>pretty[bod,$LetPrec];*)
(*currentPrecedence=$LetPrec;*)
(*];*)
(*,*)
(*_,(*Catch-all for any other unexpected head,though ideally all AST nodes are handled*)resultString=ToString[expr];*)
(*currentPrecedence=0; (*Unknown precedence,might always need parens*)*)
(*];*)
(*(*Add parentheses if the current expression's precedence is lower than its parent's.This is the core logic for minimizing brackets.*)*)
(*If[currentPrecedence<parentPrecedence,*)
(*"("<>resultString<>")",*)
(*resultString*)
(*]*)
(*]*)
(**)
(*(*Helper to collect consecutive lambda abstractions for\x y z.M syntax*)*)
(*collectLambdaChain[lamAbs[x_,bod_]]:=Module[{vars={x},currentBod=bod},While[Head[currentBod]===lamAbs,AppendTo[vars,currentBod[[1]]];*)
(*currentBod=currentBod[[2]];];*)
(*{vars,currentBod}]*)
(*collectLambdaChain[expr_]:={{},expr} (*Base case for non-lambda expressions*)*)
(**)
(**)


(* ::Input:: *)
(*viewReduc[reducSteps_]:=StringJoin[Riffle[pretty/@reducSteps," \[RightArrow]\n"]]*)
(**)
(*(*---- REPL ----*)*)


(* ::Input:: *)
(*LambdaStepNum = 200;*)
(*LambdaInterpret[lamExp_, depth_ : LambdaDepth] := viewReduc@reduce[parse@tokenize[], depth];*)


(* ::Input:: *)
(*ClearAll[REPL];*)
(**)
(*(*---Define the REPL function---*)*)
(*(*---Define the REPL function---*)(*Arguments:inputFile:Path to an input file.If "",reads from standard input ($Input).outputFile:Path to an output file.If "",writes to standard output ($Output).maxReductionSteps:Maximum number of reduction steps to perform for expressions.*)*)
(*LambdaREPL[inputFile_String:"",outputFile_String:"",maxReductionSteps_:LambdaDepth]:=Module[{inputStream,outputStream,line,result},*)
(*(*---Initialize Input and Output Streams---*)*)
(**)
(*(*---Open Input Stream---*)*)
(*Check[inputStream= If[inputFile==="",$Input,OpenRead[inputFile]],*)
(*(*If OpenRead failed,print an error and exit*)*)
(*Print["Error: Could not open input file '",inputFile,"'. Please check the path and permissions. Exiting REPL."];*)
(*Return[$Failed]; (*Exit the REPL function gracefully*)*)
(*];*)
(**)
(*(*---Open Output Stream---*)*)
(*Check[outputStream=If[outputFile==="",$Output,OpenWrite[outputFile,CharacterEncoding->"UTF8"]],*)
(*(*If OpenWrite failed,print an error and exit*)*)
(*Print["Error: Could not open output file '",outputFile,"'. Please check the path and permissions. Exiting REPL."];*)
(*If[inputFile=!="",Close[inputStream]] ;(*Close input stream if it was successfully opened*)*)
(*Return[$Failed]; (*Exit the REPL function gracefully*)*)
(*];*)
(**)
(*uniqueCounter =0;*)
(*macroDict = defaultMacroDict;*)
(*(*---Ensure streams are closed on exit or error---*)*)
(*(*This uses Protect and On to ensure Close is called even if errors occur.*)*)
(*If[inputFile=!="",*)
(*Unprotect[inputStream];*)
(*inputStream/:MakeBoxes[inputStream,StandardForm]:="InputStream[\""<>inputFile<>"\"]";*)
(*Protect[inputStream];*)
(*];*)
(*If[outputFile=!="",*)
(*Unprotect[outputStream];*)
(*outputStream/:MakeBoxes[outputStream,StandardForm]:="OutputStream[\""<>outputFile<>"\"]";*)
(*Protect[outputStream];*)
(*];*)
(*(*---Initial REPL Messages---*)*)
(*WriteString[outputStream,"--- \[Lambda]-Calculus REPL ---\n"];*)
(*WriteString[outputStream,"Input from: ",If[inputFile==="","Standard Input",inputFile],"\n"];*)
(*WriteString[outputStream,"Output to: ",If[outputFile==="","Standard Output",outputFile],"\n"];*)
(*WriteString[outputStream,"Enter expressions or macro definitions (e.g., #define ID <expression>).\n Type 'exit' or 'quit' to end.\n"];*)
(**)
(*(*---Main REPL Loop---*)*)
(*While[True,*)
(*line=If[inputStream===$Input,InputString["\[Lambda]> "],(*For interactive input,use InputString*)*)
(*WriteString[outputStream,"\[Lambda]> "];*)
(*(*For file input,print prompt and then read line*)*)
(*ReadLine[inputStream]*)
(*];*)
(*(*---Handle Termination Conditions---*)*)
(*(*EndOfFile:Reached end of an input file.*)*)
(*(*$Canceled:Input was aborted by user (e.g.,Alt+.) or stream closed.*)*)
(*If[line===EndOfFile||line===$Canceled,*)
(*WriteString[outputStream,"End of input or input canceled. Exiting REPL.\n"];*)
(*Break[] (*Exit the While loop*)*)
(*];*)
(*(*---Handle Explicit Exit Commands---*)*)
(*If[StringMatchQ[StringTrim[line],"exit"|"quit",IgnoreCase->True],*)
(*WriteString[outputStream,"Exiting REPL. Goodbye!\n"];*)
(*Break[] (*Exit the While loop*)*)
(*];*)
(*(*---Skip Empty Input---*)*)
(*If[StringLength[StringTrim[line]]==0,Continue[]];*)
(*(*Go to next loop iteration*)*)
(*result =Catch[*)
(*(*---Process Input:Macro Definition or Expression Evaluation---*)*)
(*If[StringStartsQ[StringTrim[line],"#define ", IgnoreCase->True],(*---Macro Definition Parsing---*)*)
(*Module[{macroDefTokens,macroName,macroExprTokens,macroExprAST},*)
(*macroDefTokens=tokenize[StringTrim[line]];(*Tokenize the entire macro definition line*)*)
(*(*Basic validation for macro definition format*)*)
(*If[Length[macroDefTokens]<3|| macroDefTokens[[2,1]]=!=macro,(*Check if the second token is a macro*)*)
(*Throw["Invalid macro definition format. Expected: #define <ID> <expression>\n"];*)
(*];*)
(*macroName=macroDefTokens[[2,2]];(*Extract the macro name*)*)
(*(*Reconstruct the expression string part for re-tokenization and parsing*)*)
(*macroExprTokens=Drop[macroDefTokens,2];*)
(*(*Use Check for parsing errors within the macro expression itself*)*)
(*macroExprAST=parse[macroExprTokens];*)
(*macroDict[macroName]=macroExprAST;(*Store the parsed AST in the global dictionary*)*)
(*WriteString[outputStream,"Defined macro: ",macroName," = ",pretty[macroExprAST],"\n"];*)
(*Null*)
(*],*)
(*(*---Expression Evaluation---*)*)
(*Module[{exprTokens,parsedExpr,reductionSteps,finalResultString},*)
(*exprTokens=tokenize[line];(*Tokenize the input expression*)*)
(*parsedExpr=parse[exprTokens];(*Parse the tokens into an AST*)*)
(*(*WriteString[outputStream,"Parsed AST: ",ToString[parsedExpr],"\n"];(*Print raw AST*)*)*)
(*reductionSteps=reduce[parsedExpr,maxReductionSteps];*)
(*(*Reduce the AST*)*)
(*WriteString[outputStream,viewReduc[reductionSteps],"\n"];(*Pretty-print the chain*)*)
(*(*Return the pretty-printed final reduced form for "Out:"*)*)
(*Null*)
(*];*)
(*]*)
(*];*)
(*If[result =!= Null,*)
(*WriteString[outputStream,result <> "\n"]*)
(*];*)
(*WriteString[outputStream,"\n"];*)
(*];*)
(* (*End While loop*)*)
(**)
(*(*---Close streams when the REPL loop terminates---*)*)
(*If[inputFile=!="",Close[inputStream]];*)
(*If[outputFile=!="",Close[outputStream]];*)
(*];*)
(**)
(*End[];*)
(*EndPackage[];*)
(**)
(*(*---How to Run the REPL---*)*)
(*(*Uncomment one of the following lines to start the REPL after loading this file.*)*)
(**)
(*(*1. Interactive REPL (reads from console,prints to console)*)*)
(*(*LambdaREPL[]*)*)
(**)
(*(*2. LambdaREPL with input file (reads from "input.txt",prints to console)*)*)
(*(*REPL["input.txt"]*)*)
(**)
(*(*3. LambdaREPL with output file (reads from console,writes to "output.txt")*)*)
(*(*REPL["","output.txt"]*)*)
(**)
(*(*4. LambdaREPL with both input and output files*)*)
(*(*REPL["input.txt","output.txt"]*)*)
(**)
(*(*You can also specify a different maximum reduction limit:*)*)
(*(*LambdaREPL["","",500]*)*)
(*(*---To start the REPL---*)*)
(*(*You can uncomment the line below in REPL.wls to make it start automatically on load,*)*)
(*(*or just call REPL[] from a Mathematica notebook cell.*)*)
